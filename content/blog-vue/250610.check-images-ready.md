---
description: 確保圖片都乖乖載入完成，一個都不能少！順便玩玩看 Vitest 的 Browser Mode(・∀・)９
tags: ['Vue', 'Vitest']
image: https://codlin.me/img.webp
date: 20250610
draft: true
---

![img](/img.webp){.cover}

# 甚麼？圖片還沒好喔！Σ(ˊДˋ;)

最近開發網頁列印功能時，發現使用者列印當下，圖片可能還沒出現，導致頁面不完整。%(◞‸◟ )%

怎麼辦哩？來做一個圖片載入完成的檢查吧！%(・∀・)９%

## 釐清需求

第一先來釐清需求，這個功能的目的是：

1. 確保指定 DOM 下所有圖片都載入完成
1. 如果圖片不可見（包含其父元素），則忽略
1. 需考慮 background-image

## 實作

熟悉 Web 開發的人，應該都知道圖片載入完成可以透過 `load` 事件來處理。

知道這點後，其實就很簡單了，讓我們建立一個 `useImagesReady` 來處理這件事。

`composables\use-images-ready.ts`

```ts
import { type MaybeElement, promiseTimeout, useEventListener } from '@vueuse/core'
import { pipe } from 'remeda'
import { getCurrentInstance, onMounted, ref, toValue } from 'vue'

interface UseImagesReadyParams {
  /** 不指定則為目前元件 */
  target?: MaybeElement;
  /** 強制延遲（ms），保險起見 */
  forceDelay?: number;
}

/** 偵測目標下所有圖片是否載入完成
 *
 * 暫時不考慮動態新增的圖片
 */
export function useImagesReady(params: UseImagesReadyParams = {}) {
  const {
    target,
    forceDelay = 0,
  } = params

  const totalImages = ref(0)
  const isReady = ref(false)
  const instance = getCurrentInstance()

  onMounted(() => {
    const rootElement = pipe(
      toValue(target),
      (value) => {
        if (value && '$el' in value) {
          return value.$el
        }

        return value
          ?? instance?.vnode?.el
          ?? instance?.proxy?.$el
          ?? document.documentElement
      },
      (value) => {
        if (!value) {
          return undefined
        }

        if (value instanceof HTMLElement) {
          return value
        }

        throw new Error(
          '[useImagesReady] 取得目標元素異常，請確認 target 是否為 HTMLElement 或 Vue 元件',
        )
      },
    )

    if (!rootElement) {
      isReady.value = true
      console.warn('[useImagesReady] 目標元素不存在，無法偵測圖片載入狀態')
      return
    }

    const imageElements = Array.from(
      rootElement.querySelectorAll('img'),
    )

    totalImages.value = imageElements.length

    if (totalImages.value === 0) {
      isReady.value = true
      return
    }

    let loadedCount = 0

    async function checkCompletion() {
      if (loadedCount === totalImages.value) {
        await promiseTimeout(forceDelay)
        isReady.value = true
      }
    }

    function handleEvent() {
      loadedCount++
      checkCompletion()
    }

    imageElements.forEach((img) => {
      if (img.complete) {
        loadedCount++
        return
      }

      useEventListener(img, 'load', handleEvent, { once: true })
      useEventListener(img, 'error', handleEvent, { once: true })
    })

    checkCompletion()
  })

  return {
    isReady,
    totalImages,
  }
}
```

## 來個測試

先前都用 Playwright 測試，這次來用 Vitest 的 Browser Mode 測試看看。%(｡･∀･)ﾉﾞ%

Browser Mode 最大的差別在於不用像 Playwright 一樣開啟指定頁面

Vitest 會在內部自動處理，開發者用起來就如同平常寫單元測試一樣單純。

::: tip
Playwright 其實可以單純測試元件，不過此功能正在實驗中。

而因單元測試通常是 Vitest，如果測試都能在 Vitest 完成，整合性更高、更方便。

[Playwright test-components](https://playwright.dev/docs/test-components)
:::

## 總結 🐟

雖然還有一些情境與邊界問題還未考慮，不過這樣已經很夠用惹。
