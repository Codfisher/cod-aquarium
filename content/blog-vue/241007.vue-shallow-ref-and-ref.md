---
title: Vue 的 shallowRef 是啥？和 ref 有甚麼差別？
description: 
tags: ['vue']
image: https://codlin.me/vue-shallow-ref-and-ref.webp
date: 20241007

head:
  meta:
    - name: 'keywords'
      content: 'cod, lin'
---

# Vue 的 shallowRef 是啥？和 ref 有甚麼差別？

![vue-shallow-ref-and-ref](/vue-shallow-ref-and-ref.webp){height="600"}

使用 Vue 的朋友們一定知道 `ref` 是啥。ԅ( ˘ω˘ԅ)

不知道大家有沒有注意到 Vue 還有一個名字有點像的 API，叫做 `shallowRef`。

`shallowRef` 和 `ref` 有甚麼差別呢？

顧名思義，簡單來說 `shallowRef` 只對淺層（第一層）進行響應式處理。

也就是說以下程式碼。

```vue
<script setup>
import { shallowRef } from 'vue'

const shallowData = shallowRef({ cod: [] })

async function updateShallowData() {
  shallowData.value.cod.push('fish')
}
</script>

<template>
  <div>
    shallowData: {{ shallowData.cod.length }}
  </div>
  <button @click="updateShallowData">
    更新資料
  </button>
</template>
```

[程式碼傳送門](https://play.vuejs.org/#eNp9kk1OwzAQha8y8qZFQukCVlVA/C5gAQjYYRbBmTQGx7ZiuxRFWXMDJMQlkOBMFcdg4tBSBGJnz7z3/I3thu1am0wDsjFLnail9eDQB7vNtaysqT004MpMKXN/jgW0UNSmggE5BlxzLYx25OgFB5nPYGtFPmxAmHwMV9fQrnXyzD1oAUXQwkujIdg883jx7R6uQcM1rAYm00wFTCgnscGVw0EhXTmgtJbrdNQjEyxtPFZWUR7tANJcTuPiR9gYmuU4MbyLVagnvoSWAsk3WhjTm+A9Qe4IJcXdFme/aDn7OmH+8j5/ev14e5w/PfchvZfa6WiJxdaZd3RhhZwkt85ouvI4LGfCVFYqrE9tdy2OM+LskzmLpx3Hmq8Dri/qokRx90f91s26GmdnNTqsp8jZsuezeoK+bx9enOCM1stmZfKgSP1P8xydUaFj7GV7QeeEvaKLtEfx40g9uXSHM4/aLYbqQDtlG/Wc0S/a/2f0b9yNZDP66NVZ+wk04O8u)

當我們點擊「更新資料」按鈕時，`{{ shallowData.cod.length }}` 部分不會被更新，文字會保持 shallowData: 0。

除非 `updateShallowData` 內容改成：

```ts
async function updateShallowData() {
  const cod = [...shallowData.value.cod, 'fish'];
  shallowData.value = { cod }
}
```

這樣就會因為第一層，也就是 `shallowData.value` 的值被改變，才會觸發響應，讓畫面更新。

或者使用 `triggerRef` 觸發響應也可以。

```ts
async function updateShallowData() {
  shallowData.value.cod.push('fish')
  triggerRef(shallowData)
}
```

看到這裡你可能會想「怎麼搞得更麻煩了？ლ（´口`ლ）」

別急別急，讓我們來看看為甚麼需要 `shallowRef` 這個玩意思。

## shallowRef 的使用場景

只對第一層的值進行響應式處理，最主要的目的就是「性能考量」。

如果對很龐大的物件進行響應式處理，會導致性能下降。

例如以下程式碼。

```vue
<script setup>
import {
  ref, shallowRef,
  watch, triggerRef,
  nextTick
} from 'vue'

/** 建立一個 10 個 key，每個 value 為長度 1000 的大型物件 */
function createData() {
  const data = {
    cod: [],
  }

  for (let i = 0; i < 10; i++) {
    const key = crypto.randomUUID();
    data[key] = new Array(1000).fill('fish');
  }

  return data;
}

/** 使用 ref 包裝的資料 */
const data = ref(createData())
watch(data, () => {
  console.log('[watch] data');
}, { deep: true })

async function updateData() {
  console.time('updateData');
  data.value.cod.push('fish')
  await nextTick();
  console.timeEnd('updateData');
}

/** 使用 shallowRef 包裝的資料 */
const shallowData = shallowRef(createData())
watch(shallowData, () => {
  console.log('[watch] shallowData');
}, { deep: true })

async function updateShallowData() {
  console.time('updateShallowData');
  shallowData.value.cod.push('fish')
  triggerRef(shallowData)
  await nextTick();
  console.timeEnd('updateShallowData');
}
</script>

<template>
  <div>
    data: {{ data.cod.length }}
  </div>
  <button @click="updateData">
    更新資料
  </button>

  <hr>

  <div>
    shallowData: {{ shallowData.cod.length }}
  </div>
  <button @click="updateShallowData">
    更新資料
  </button>
</template>

```

[範例程式碼](https://play.vuejs.org/#eNqVlU1v00AQhv/KyJc4JXKC4JSmFYX2UA6A+nHq9mDsje3WXlvrddIoslQhEEKtxAUqAYILiA9xAAkEqAXxZ5qknPgLzK6d2rRVoCd7Z9+dfeeZ9bqvzUWR0Umo1tRascW9SEBMRRLNEuYFUcgF9AkD4LRdg9g1fT/sLuG7jHVNYbk1ENxzHMrHUUa3xIpnbRKWQpuHAVQwe4UwwupTUzA42B+93zn8tj3Y3oGLDZCPTdr7/X13+OGhHHRMP6EwurP/6/HXwf5r1DQaMHp6d/DqzeDFzujBu8ODLzBVJ6ydMEt4IQOLU1PQeVOYejUza4UsFmBjBGayiIzZTVhbVxZT6QagHXLQfSrAQ1ljGh8t3A6fFy7kicap0CFKLN6LRGhwk9lhsLq6OK9XpzOV3GoNReuoYrQLc5ybPV1arxptz/f1StuL3Uomz3fnSJkztRTDKigBHf74OXr0VvKGwe69o5fPsfajT/eHe09U1X+VhiK9XH2VMNUTXc7XAHHMzBZEQp8afujolTUlWldZlKe0Bn2wKY2a2Eykn2Iiwsy4xyw4xpxEqD+FWSYVXkD1SjGf1ynTG6qdBsI3oiR2xxzktNk1PXF8WnKU5ZQLzD6V9SSm4kROoJWLZBKEViw5m11J/W+EJfF5SS4XSycBLclyrqU9J+AtvspyRecmf3J7bECrnt0TeEPgQNAg8lGII4CW7XXUS9b9JvSRhvQpHfqUOcKFFFOgsj6Wtm4nQiCVK5aPbmaIVrScaHmy4bPPw72PWWOz1dkiZQGHLh+/FQZKVSsfZWznt1Pi8D+uWvUSF62miRj5tj3H2IhDhletajfRrDCIPJ/ym5E8GDHR0GmWm2hqv+sqJo+SurjUGpdam2fEN+ItGSPaLU5jyjuUaMdzwuQOFdn0wvIN7HxpMgjtxEf1hMklimcjkR4z2dWE2Wi7pFNuF9UPw2POSrywJSiLx0VJo+rqU3qi4R/h2oTSC7uXjMv5lZlq6R9PPGXz)

以上程式的邏輯為：

1. `createData` 建立一個 10 個 key，每個 value 為長度 1000 的大型物件。
1. 分別使用 `ref` 和 `shallowRef` 對 `createData` 的結果進行包裝。
1. `nextTick` 表示響應資料改變、等待 DOM 下次更新，配合 `console.time` 計算更新資料所需時間。

現在大家可以點擊看看兩者的「更新資料」按鈕，看看更新資料所需時間。

會在 console 中看到以下資訊。

```shell
[watch] data
updateData: 7.468994140625 ms
[watch] shallowData
updateShallowData: 0.60498046875 ms
```

可以注意到 `shallowData` 的更新時間比 `data` 快近 10 倍！

路人：「雖然快了 10 倍，但是實際上也才花了 7ms，更不用說平常用不到這麼大的物件，是不是不用也無所謂啊？」

鱈魚：「你說也錯，平常很難遇到大型物件，不過還要是注意一些情境。」

### 配合第三方套件

當你使用 pixi、babylon.js 這類套件時，套件本身會建立各種複雜物件，例如：Engine、Scene、Mesh 等等。

雖然一般情況下，完全不需要 `ref`，直接使用即可。

```ts
// ❌ 不需要 ref 包裝
const engine = ref(new Engine(canvas, true));

// ✅
const engine = new Engine(canvas, true);
```

但是有時候還是需要包裝怎麼辦？這個時候就可以用 `shallowRef` 了！

直接使用 `ref` 包裝，會讓畫面會卡到爆炸喔。

::alert{type="primary"}
例如酷酷元件中的 [useBabylonScene](https://gitlab.com/side_project/chill-component/-/blob/main/src/composables/use-babylon-scene.ts?ref_type=heads#L67)，用於快速建立一個 3D 場景。其中的 babylon.js 相關物件就是使用 `shallowRef` 包裝。
::

## 總結 🐟

- `shallowRef` 只對第一層進行響應式處理，適合大型物件。
- 配合第三方套件的複雜物件時，使用 `shallowRef` 可以避免拖垮性能。
