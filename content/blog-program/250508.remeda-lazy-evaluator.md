---
title: 懶懶也有好處啦，試試 Remeda 的 lazy evaluator
description: remeda 實作中有 lazy evaluator 這個是啥？有甚麼好處？來 Bench 一下看看◝( •ω• )◟
tags: ['Remeda', 'JavaScript']
image: https://codlin.me/remeda-lazy-evaluator.webp
date: 20250526
draft: true
---

![remeda-lazy-evaluator](/remeda-lazy-evaluator.webp){.cover}

# 懶懶也有好處啦，試試 Remeda 的 lazy evaluator

故事發生於某天平凡的午後，鱈魚我和平常一樣快樂地用著 [`Remeda`](https://remedajs.com/)，使用 [`take`](https://github.com/remeda/remeda/blob/main/packages/remeda/src/take.ts) 時忽然很好奇原始碼如何實作。

<br/>
旁白：「『未看先猜一定是 `Array.slice` 啦！』鱈魚邊說邊打開程式碼，結果出現火星文，看不懂的大笨魚只能失落的挺著肥肚肚，望之興嘆。」

鱈魚：「給我照腳本念，不要偷嘴我！%ლ（´口`ლ）%」
<br/>
<br/>

讓我們看看 `Remeda` 的 `take` 原始碼：

```ts
export function take(...args: ReadonlyArray<unknown>): unknown {
  return purry(takeImplementation, args, lazyImplementation)
}

function takeImplementation<T extends IterableContainer>(array: T, n: number): Array<T[number]> {
  return n < 0 ? [] : array.slice(0, n)
}

function lazyImplementation<T>(n: number): LazyEvaluator<T> {
  if (n <= 0) {
    return lazyEmptyEvaluator
  }

  let remaining = n
  return (value) => {
    remaining -= 1
    return { done: remaining <= 0, hasNext: true, next: value }
  }
}
```

`purry` 是 `Remeda` 特殊函數，不在此文章討論範圍，有興趣的朋友可以來[這裡看看](https://remedajs.com/docs/#purry)。

可以看到的確有 `Array.slice` 沒錯，不過還有 `lazyImplementation` 部分，這個其實就是實作「惰性求值」（Lazy Evaluation）邏輯。

至於甚麼是「惰性求值」？簡單來說，就是在需要時才計算，而不是一開始就計算所有東西。

細節網路上超多文章，這裡就不贅述了。%(ゝ∀・)y%

## 來 Bench 一下

讓我們來 Bench 一下，感受看看差異吧。

邏輯為：將一個巨大的矩陣 map、filter 後，只取前 5 筆資料。

資料定義如下：

```ts
export const mapFn = (x: number): number => x * 2
export const filterFn = (x: number): boolean => x % 3 === 0
export const TAKE_COUNT = 5

const DATA_SIZE = 1_000_000
export const data = Array.from({ length: DATA_SIZE }, (_, i) => i + 1)
```

總共測試三種版本程式：

Remeda 的 `lazy` 版本：

`lazy.ts`

```ts
import { filter, map, pipe, take } from 'remeda'

pipe(
  data,
  map(mapFn),
  filter(filterFn),
  take(TAKE_COUNT)
)
```

原生 Array 版本：

`native.ts`

```ts
data
  .map(mapFn)
  .filter(filterFn)
  .slice(0, TAKE_COUNT)
```

將 `Remeda` function 拆開來用，不要使用 `lazy`：

`no-lazy.ts`

```ts
import { filter, map, take } from 'remeda'

const mapped = map(data, mapFn)
const filtered = filter(mapped, filterFn)
take(filtered, TAKE_COUNT)
```

[Bench 程式碼](https://benchjs.com/playground#/N4IgzgLghhCmIC5QDdYCcwEsD2A7RAjADQiYC2ADgDaxmy7QQ65iIDaomAJoiAMIB1AQC8ACgBUAEl2EB9PtgBmAZgAeAdgByAWUniAHCBKLMNXFDq8qUYQE8AdBFYkAxnjgNe5CtjQQABMD+ZFAURP4mVHBo4dAA1rDhFJgUsP4AvhFo2GT+AORotLBcUHkAOrgVsKo+fv5uLAFoAK64-gC8-gAUAJQdAHyBFf7+hRDNaG3JqV3DI-4l0ERzIyEUXWsAYrg9y23zkdFdh+jbuyv+8bBd4gCCANIAovIA8gCqmuI9cz0A3BXpX4gdJETg8BAgABaAE04i4AIpvAAMBDeAE5FAANe64ABWzVuLkwAHcACxGECRegWeAQ3DYAC01jsjmcIAaHggXkovgCQTW4ROMUuUASGSyOXyhToJXKlVw1VqAQakFGrQ63T67UGwDmKoCa1SXA1ay6iyg4S2O1+81tIz1eFVQuKGqFG1CRsFpmiZxtczGEzaV2O3vQxXCdyerw+X3+uEBwNBpHB-AAjgALTQANmJSOUAHF86FocgCEjFGQ+AARYkUqnmSx0mCYVCsikc+hciFVGq8+qOprqzq9AZDfYByYLGBQC72U1W777Eb2N1Cs6zsBUTAua5IiMPZ58d6fP4AoHpAC6JCgLiYqHEUAARgBJFN8DPZ3MFosUEtlivVrWJBgLA4wUAoXC0iAip9vqwShNsGpdKoCD+LgzRkI+6A9Kh6GYego6qP4ABU-gAExxjBdRwWubTDihaEYVhaA4f4j7YNgNBQHRgxEQApP4ygdO0nRIpRvbUQO-iRoex7iBqACscYVHBVa3HcsgAMrPpCjwagQshIkZhlGX6CoScqUnmhqtxoGgUAOIo2RkF0QRmAA5hA6aoWpGnabpGThF0sjhJgWqDJg-gANT+AQp74MBoHNBQVbiJpvCQS41iFP47lUNgj5QFQY4jJl2VpHBVqochuFMdho54cxcalbAWVQDlNGhmg2zVQxjX1dqbEcVxuDNQsrXlf2jTSQe0afIpY1le1FVWdOtX4WgbAXmNAIVD2SqBAmJCFFAXB0AoDCdrwADE-jws025xP4mnQHU+YPZBe24Ndt2bKYaQvS0t4TLAFQMv4IFgayqGaUlFD9pBlzYP4FCFBQy1Tks9QnXA-jprAVCpGgEStLezBgOEoEuPYYP+N4NB0AwzaOgA9MR9jAE4RC4mA6Soc+lAM52zNtFSYBTdAmC4FL7lsfQLjpiEaBxNsX0-f4AhoJgTC4LLABC8uK+1cRgF9BD2M9cPdJDyWsjhX2PKgaC2F5Mv+LY2DNP4VEBMSpjFVh-hQMgUCmE+NBB+LUC5flhXFYovjeze6Z04LRRM0weA0-KAAGecQLYqRgC4WsUBAFQsyz2OwDAaTccaPuXLAqrmvtsGrdANl2Q5K7Oa5-geV5qFlkZgXdCFdPhZP4kHXBYAYUh7VoOtzFbVPS-2IUXDNDuXRdBabHr9FbHhEi8V5znX1kRbAvUOnjDk901QWHfdsIF9t9CxnzAMmAqREiYFwCM0juWwM3PGYZwj13dp7NCsAXQQGRo3aOihSaZzaA2F0BRWh5GzhUC+Bci4lxSOXcys8pItDopqUcupxxJUnOaTexQd7XHnmQU+8V0j4LzhUCkW5Hz2S1s3dgoBMG8GlMUKAwILwghAE7LAeBCDpCAA)

可以看到結果差距非常驚人。

| Name       | Ops/sec                                         |
|------------|-------------------------------------------------|
| lazy.ts    | <span style="color:green">1,113,819 Best</span> |
| no-lazy.ts | <span style="color:orange">63 (-100.0%)</span>  |
| native.ts  | <span style="color:orange">61 (-100.0%)</span>  |

- `lazy` 版本表現最佳，達到每秒 111 萬次操作，遠超過其他兩個版本。

- `no-lazy` 與 `native` 版本表現相近很合理，因為 `Remeda` 的 `map`、`filter` 都是使用原生的 `Array.map`、`Array.filter`。

`lazy` 版本會那麼快，是因為它只計算到 `take` 的部分，並不會計算整個資料集，所以時間才差那麼多。

## 所以都該懶懶的嗎？\_(:3」ㄥ)\_

倒也不能這麼說，讓我們去掉 `take` 的部分，再跑一次看看。

| Name       | Ops/sec                                      |
|------------|----------------------------------------------|
| lazy.ts    | <span style="color:orange">19(-70.4%)</span> |
| no-lazy.ts | <span style="color:green">64Best</span>      |
| native.ts  | <span style="color:orange">63(-1.8%)</span>  |

可以看到 `lazy` 的效能大幅下降，甚至比不上 `no-lazy` 版本。

這是因為 `lazy` 的 `take` 只在需要時才計算，當沒有 `take` 時，整個資料集都需要計算，這樣就失去了惰性求值的優勢，反而會因為 `lazy` 額外的計算邏輯，導致效能下降。

或者把資料數量改成 50 筆，再跑一次。

| Name       | Ops/sec                                              |
|------------|------------------------------------------------------|
| lazy.ts    | <span style="color:orange">1,017,423 (-36.0%)</span> |
| no-lazy.ts | <span style="color:orange">1,539,932 (-3.2%)</span>  |
| native.ts  | <span style="color:green">1,590,550 Best</span>      |

可以看到 `lazy` 版本下降惹 %Σ(ˊДˋ;)%

這是因為瀏覽器為了 JS 性能操碎了心，這點資料才不算甚麼，`lazy` 的計算邏輯反而拖累了性能。

以上就是這次的超不專業的不嚴謹實驗。%੭ ˙ᗜ˙ )੭%

老話一句：究竟誰比較快，會因為情境、runtime、瀏覽器最佳化與程式寫法而有所不同，最好應該實際跑過 benchmark 再做選擇。

## 總結 🐟

- `Remeda` 的 `lazy` 版本在處理大量資料時，能夠避免不必要的計算，提升效能。
- 不過當資料量小時，`lazy` 反而會拖慢效能。
- 性能會因情境、runtime、瀏覽器最佳化與程式寫法而有所不同，最好應該實際跑過 benchmark 再做選擇。
