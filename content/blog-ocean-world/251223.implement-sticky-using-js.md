---
description: CSS sticky 好用，但是有限制，讓我們想辦法突破限制吧。
tags: ["JavaScript", "Vue"]
image: https://codlin.me/implement-sticky-using-js.webp
pubDate: 20251223
---

<script setup>
  import CssSticky from './implement-sticky-using-js/css-sticky.vue'
  import CssStickyNoEffect from './implement-sticky-using-js/css-sticky-no-effect.vue'
  import VisibleAreaIntersection from './implement-sticky-using-js/visible-area-intersection.vue'
  import UseVSticky from './implement-sticky-using-js/use-v-sticky.vue'
</script>

![implement-sticky-using-js](/implement-sticky-using-js.webp){.cover}

# 那些黏不起來的元素，讓我們加點 JS 吧！

大家有沒有這種經驗？

快樂的在 CSS 中設定了 `position: sticky`，給了它 `top: 0` 的承諾、加上背景顏色怕它迷失，甚至提高了 `z-index` 把它捧在手心

結果使用者隨手一滑，它就這麼頭也不回地就走了，徒留一片空白的寂寞。%( ´•̥̥̥ ω •̥̥̥` )%

<br>

鱈魚：「你說是不是很沒良心？%゜・(PД`q｡)・゜%」

路人：「...你說的還是 CSS 嗎？%(´・ω・`)%」

## 甚麼是 sticky

sticky 是一種特殊的定位方式，結合了 relative 和 fixed 的特性。

當元素滾動到指定位置時，會「黏住」並固定在視窗或滾動容器內的某個位置，直到其父容器的邊界不可見為止。

<css-sticky />

嘗試滾動上面這個範例，可以發現 sticky 元素會黏在視窗的頂部，不會像 relative、absolute 元素一樣滾出視窗。

好用是很好用，但是 CSS sticky 也有限制，像是多層滾動區域無法正常工作：

<css-sticky-no-effect />

雖然外層被捲動，導致內容看不見很合理，但是我就想要他黏住怎麼辦呢？

## 萬用 sticky

CSS 老弟沒辦法，我們還有 JS 大哥啊！%◝( •ω• )◟%

讓我們透過 JavaScript 來實現萬用 sticky 效果吧。

概念不複雜，過程如下：

1. 找出目標元素所有的「可捲動祖先」
1. 計算「多層可視區交集」
1. 最後使用 translate 模擬 sticky 效果

<br>

重點在於「可視區交集」，因為內容其實被好幾層容器「裁切」後才看得到，所以元素要滾到哪，取決真正的「可視範圍」

可視範圍即為每一層 scroll 容器的可視區交集，你說甚麼叫做可視區交集？

讓我們具象化一下：%✨◝( •ω• )◟✨%

<visible-area-intersection />

這樣是不是比較清楚多了？知道概念後，讓我們來實作吧%( ´ ▽ ` )ﾉ%

## 實作

讓我們一步一步來實作吧

### 工具函式

首先我們需要一些工具函式來幫助我們取得滾動容器、計算可視區交集等等。

<<< ../../web/directives/v-sticky.ts#utils

### Vue 指令

這裡將 sticky 效果封裝成 Vue 指令，在目標元素上加上 `v-sticky` 就可以使用，相當方便。

首先定義指令參數與取得參數的 function：

<<< ../../web/directives/v-sticky.ts#options

接著是核心邏輯：更新與還原。

```ts
const oriStyle = {
  translate: el.style.translate,
  willChange: el.style.willChange,
};

let appliedY = 0;
let rafId = 0;

const update = async () => {
  if (rafId) return;

  /** 用 requestAnimationFrame 省去多餘的更新 */
  rafId = requestAnimationFrame(() => {
    rafId = 0;
    if (!el.isConnected) return;

    const parentRect = parentEl.getBoundingClientRect();
    const rootRect = getEffectiveRootRect(parentEl);
    const elRect = el.getBoundingClientRect();

    /** 扣掉目前位移，原始 top 位置 */
    const naturalTop = elRect.top - appliedY;
    const deltaInParent = naturalTop - parentRect.top;

    const minTop = rootRect.top + opts.top;
    let nextY = Math.max(0, minTop - naturalTop);

    // 卡在父元素底部，不要超出去
    const maxYRaw =
      parentRect.height - (deltaInParent + elRect.height) - opts.bottomPadding;
    const maxY = Math.max(0, maxYRaw);
    nextY = Math.min(nextY, maxY);

    if (Math.abs(nextY - appliedY) > 0.5) {
      appliedY = nextY;
      el.style.translate = `0px ${appliedY}px`;
    }
  });
};

const restore = () => {
  if (rafId) cancelAnimationFrame(rafId);
  rafId = 0;
  el.style.translate = oriStyle.translate;
  el.style.willChange = oriStyle.willChange;
};
```

最後完成整個指令：

<<< ../../web/directives/v-sticky.ts#directive

- `useEventListener`、`useXxxxObserver` 用於監聽事件並觸發更新
- `effectScope` 用於管理指令的生命週期，先前的[文章有提過](/blog-vue/vue-directive-and-effect-scope)


## 成果

在目標元素上加上 `v-sticky`，不管在哪個滾動容器中，都能正常黏住。

<<< ./implement-sticky-using-js/use-v-sticky.vue

<use-v-sticky />

## 總結 🐟

完整程式碼可以[在此取得](https://github.com/Codfisher/cod-aquarium/tree/web/directives/v-sticky.ts)

- CSS sticky 好用，但是有限制
- 使用 JavaScript 實現萬用 sticky 效果，突破 CSS sticky 限制
