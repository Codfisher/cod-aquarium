---
description: 如何實現靈活的資料排序
tags: ['Algorithm']
image: https://codlin.me/img.webp
date: 20250807
---

![img](/img.webp){.cover}

# 如何實現靈活的資料排序

最近遇到一個希望能夠任意排序資料的需求，研究了一輪後找到了一個有趣的解決方案。

方案是一個名為 Fractional indexing 的演算法，能夠實現靈活的資料排序。

其特點為能夠在現有清單中任意位置插入新資料且不改變其他資料順序的情況下進行排序。

白話來說，就是可以讓資料任意插隊的感覺。%◝( •ω• )◟%

讓我們一步步探討看看。

## 如何排序？

如何自由調整資料排序呢？%ლ(╹ε╹ლ)%

有人可能會想說：「阿不就調整矩陣順序就好了？%( ˘･з･)%」

不過那是在同一個矩陣中才有辦法，如果是從 DB 取出來呢？

DB 內的資料通常都只能依靠某個欄位進行排序取值，不能像矩陣換個位置就行。

舉個類比情境，假設今天有多個資料如下：

```ts
const data = {
  1: {
    name: 'cod',
    age: 10,
  },
  2: {
    name: 'cat',
    age: 1,
  },
  3: {
    name: 'dog',
    age: 4,
  },
}
```

需要將此 `data` 內容轉換成矩陣，若依據 `age` 排升序則為：

```ts
const list = [
  {
    name: 'cat',
    age: 1,
  },
  {
    name: 'dog',
    age: 4,
  },
  {
    name: 'cod',
    age: 10,
  },
]
```

`object` 不會保證資料順序，所以直接轉換成 `array` 不能保證順序正確，一定要先 `sort()` 才行。

剛剛我們依照 `age` 排序，現在需求改成可以隨意調整資料順序，該怎麼做呢？

大家可能應該都想到方法了，新增一個 `order` 欄位不就好了嗎？

```ts
const data = {
  1: {
    name: 'cod',
    age: 10,
    order: 1,
  },
  2: {
    name: 'cat',
    age: 1,
    order: 2,
  },
  3: {
    name: 'dog',
    age: 4,
    order: 3,
  },
}
```

若要移動位置，只需要調整 `order` 欄位的值即可。

例如：將 `dog` 移到 `cat` 前面，只需要將 `dog` 的 `order` 改成 `1.5` 即可。

這就是 Fractional indexing 的核心概念！%( •̀ ω •́ )✧%

只是此演算法的數值範圍使用 0 到 1 之間的浮點數。

::: tip
至於為甚麼是 0 到 1 之間，這個倒是沒有特別找到具體的原因，若有大大知道為甚麼還請不吝告訴我。%(*´∀`)~♥%
:::

這個演算法來自鼎鼎大名的 Figma，其 CTO 分享的[這篇文章](https://madebyevan.com/algos/crdt-fractional-indexing/)。

文章內有很生動的互動效果，能夠讓人更直覺地理解 Fractional indexing 運作方式。

## 浮點數精度

不過這裡還有個小問題，就是浮點數的精度有限，若交換太多次可能會導致因精度不足，讓排序異常。

以 JS 的數字（IEEE 754 的 64 位元雙精度浮點數）為例，小數點後最多大約可以正確表示到 15~17 位數字，若超過這個範圍，會出現數值遺失問題。

有沒有可以存好存滿的方法呢？那就用字串吧！同時使用 Base62 編碼，讓字串短一點。%(・∀・)９%

::: tip
有時候也會使用字串表示數值，避免潛在的精度損失問題。

[Decimal.js](https://github.com/MikeMcl/decimal.js?tab=readme-ov-file#use:~:text=it%20is%20recommended%20to%20pass%20strings%20rather%20than%20numbers%20to%20avoid%20a%20potential%20loss%20of%20precision.)
:::

甚麼是 Base62 編碼？是一種將資料轉換成只包含 62 個可列印字元的編碼方式，62 個字元包括：

數字：0 到 9（共 10 個）

大寫英文字母：A 到 Z（共 26 個）

小寫英文字母：a 到 z（共 26 個）

總共：10 + 26 + 26 = 62 個字元

舉個簡單的例子：

假設要將十進位的數字 125 轉成 Base62：

62 進位下，125 ÷ 62 = 2 餘 1 → 第一個字元是 1

2 ÷ 62 = 0 餘 2 → 第二個字元是 2

所以 Base62 為 21（反過來寫）

## 總結 🐟
