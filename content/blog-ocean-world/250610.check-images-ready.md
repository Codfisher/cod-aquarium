---
description: 確保圖片都乖乖載入完成，一個都不能少！順便玩玩看 Vitest 的 Browser Mode(・∀・)９
tags: ['Vue', 'Vitest']
image: https://codlin.me/img.webp
date: 20250610
draft: true
---

![img](/img.webp){.cover}

# 甚麼？圖片還沒好喔！Σ(ˊДˋ;)

最近開發網頁列印功能時，發現使用者列印當下，圖片可能還沒出現，導致頁面不完整。%(◞‸◟ )%

怎麼辦哩？來做一個圖片載入完成的檢查吧！%(・∀・)９%

## 釐清需求

第一先來釐清需求，這個功能的目的是：

1. 確保指定 DOM 下所有圖片都載入完成
1. 如果圖片不可見則忽略
1. 需考慮 CSS background-image

## 實作

熟悉 Web 開發的人，應該都知道圖片載入完成可以透過 `load` 事件來處理。

知道這點後，其實就很簡單了，讓我們一步一步來。

這裡以 Vue 為例，建立一個名為 `useImagesReady` 的 Composition API。

### 取得目標的 HTML 元素

我們的參數支援直接使用 Vue 元件，所以要先處理一下，讓我們可以取得目標的 HTML 元素。

```ts
interface UseImagesReadyParams {
  /** 不指定則為目前元件 */
  target?: MaybeElement;
  /** 強制延遲（ms），保險起見
   * @default 0
   */
  forceDelay?: number;
  /** 是否包含 background-image
   * @default true
   */
  includeBackgroundImages?: boolean;
}

/** 偵測目標下所有圖片是否載入完成
 *
 * 目前不考慮動態新增的圖片
 */
export function useImagesReady(params: UseImagesReadyParams = {}) {
  const {
    target,
    forceDelay = 0,
    includeBackgroundImages = true,
  } = params

  const totalImages = ref(0)
  const isReady = ref(false)
  /** 取得目前元件實例 */
  const instance = getCurrentInstance()

  onMounted(() => {
    const rootElement = pipe(
      toValue(target),
      (value) => {
        if (value && '$el' in value) {
          return value.$el
        }

        return value
          ?? instance?.vnode?.el
          ?? instance?.proxy?.$el
          ?? document.documentElement
      },
      (value) => {
        if (!value) {
          return undefined
        }

        if (value instanceof HTMLElement) {
          return value
        }

        throw new Error(
          '[useImagesReady] 取得目標元素異常，請確認 target 是否為 HTMLElement 或 Vue 元件',
        )
      },
    )

    if (!rootElement) {
      isReady.value = true
      console.warn('[useImagesReady] 目標元素不存在，無法偵測圖片載入狀態')
      return
    }
  })

  return {
    isReady,
    totalImages,
  }
}
```

::: tip 那個 `pipe` 是甚麼咚咚？
不知道的朋友們可以來這裡[看看](/blog-program/remeda-pipe)
:::

### 取得所有圖片

接著是取得圖片部分，先新增一個判斷 image 是否可見的 function。

若其父元素隱藏，則圖片一定也看不到，所以要一路找上去，~~把列祖列宗都找出來 %ლ（´∀`ლ）%~~。

```ts
function isElementVisible(el: HTMLElement | null) {
  /** 一路往父層檢查 */
  while (el) {
    const style = getComputedStyle(el)
    if (style.display === 'none' || style.visibility === 'hidden') {
      return false
    }
    el = el.parentElement
  }
  return true
}
```

::: tip 怎麼不用 `offsetParent`？%ლ(╹ε╹ლ)%
研究中有找到 `offsetParent` 這個屬性，當父元素 `display: none` 時會是 `null`，就可以不用一路往上找。

只是父元素為 `position: fixed` 也會是 `null`，這樣會誤判，所以不行。%ლ(╹ε╹ლ)%

[HTMLElement: offsetParent property](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent)
:::

<br>

接著取得目標元素下的所有圖片。

```ts
const imageElements = Array.from(rootElement.querySelectorAll('img'))
  .filter((img) => !!img.src && isElementVisible(img))
```

接著取得背景圖片並轉換成 `HTMLImageElement`，最後合併到 `imageElements`。

```ts
const backgroundImageElements = Array.from(
  includeBackgroundImages
    ? rootElement.querySelectorAll('*')
    : [],
).reduce((list, el) => {
  if (!(el instanceof HTMLElement) || !isElementVisible(el)) {
    return list
  }

  const bgValue = getComputedStyle(el).getPropertyValue('background-image')
  if (bgValue && bgValue !== 'none') {
    // 只處理 url 的背景圖片
    const url = bgValue.match(/url\(["']?([^"']+)["']?\)/)
    if (!url || !url[1]) {
      return list
    }
    const img = new Image()
    img.src = url[1]
    list.push(img)
  }

  return list
}, [] as HTMLImageElement[])

const imageElements = Array.from(rootElement.querySelectorAll('img'))
  .filter((img) => !!img.src && isElementVisible(img))
  .concat(backgroundImageElements)
```

### 圖片載入事件

圖片到齊了，剩下就是處理載入事件了，這裡我們使用 VueUse 的 [`useEventListener`](useEventListener)。

```ts
export function useImagesReady(params: UseImagesReadyParams = {}) {
  // ...

  onMounted(() => {
    // ...

    const imageElements = Array.from(rootElement.querySelectorAll('img'))
      .filter((img) => !!img.src && isElementVisible(img))
      .concat(backgroundImageElements)

    totalImages.value = imageElements.length

    if (totalImages.value === 0) {
      isReady.value = true
      return
    }

    let loadedCount = 0

    async function checkCompletion() {
      if (loadedCount === totalImages.value) {
        await promiseTimeout(forceDelay)
        isReady.value = true
      }
    }

    function handleEvent() {
      loadedCount++
      checkCompletion()
    }

    imageElements.forEach((img) => {
      if (img.complete) {
        loadedCount++
        return
      }

      useEventListener(img, 'load', handleEvent, { once: true })
      useEventListener(img, 'error', handleEvent, { once: true })
    })

    checkCompletion()
  })

  return {
    isReady,
    totalImages,
  }
}
```

這樣就完成了，當所有圖片載入完成（或錯誤）後，`isReady` 會變成 `true`。

雖然還有一些情境與邊界問題還未考慮，不過這樣已經很夠用惹。%ԅ(´∀` ԅ)%

## 來個測試

先前都用 Playwright 測試，這次來試試看 Vitest 的 Browser Mode。%(｡･∀･)ﾉﾞ%

Browser Mode 最大的差別在於不用像 Playwright 一樣開啟指定頁面

Vitest 會在內部自動處理，開發者用起來就如同平常寫單元測試一樣單純。

::: tip
Playwright 其實也可以測試元件，不過此功能正在實驗中。

而因單元測試很常使用 Vitest，如果測試都能在 Vitest 完成，整合性更高、更方便。

[Playwright test-components](https://playwright.dev/docs/test-components)
:::

首先來

## 總結 🐟

- 測試圖片載入狀態的功能，確保列印時圖片都載入完成
- 使用 Vue 的 Composition API 實作 `useImagesReady`
- 使用 `useEventListener` 偵測圖片載入事件
- 使用 Vitest 的 Browser Mode 進行測試
