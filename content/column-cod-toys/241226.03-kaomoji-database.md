---
title: CodToys - EP03：顏文字資料庫
description: 上一章節我們完成了快捷鍵開關視窗功能，這一章節我們來實作功能選項部分吧！
tags: ['CodToys', 'Electron']
image: https://codlin.me/cod-toys.webp
date: 20241227
---

# CodToys - EP03：顏文字資料庫

![快樂堆積木的魚](/cod-toys.webp)

上一章節我們完成了快捷鍵開關視窗功能，這一章節我們來實作功能選項部分吧！

## 開發

本章節預計會建立以下內容：

- 產生 Tray：用來查看狀態與開啟設定視窗
- 儲存設定檔：儲存使用者之 Notion API 資料
- 連接 Notion Database
- 模糊搜尋顏文字資料

### 產生 Tray

使用 [Tray 模組](https://www.electronjs.org/docs/latest/api/tray)，輕鬆完成。◝( •ω• )◟

同時將 `app` 的 `window-all-closed` 事件移到 `app.whenReady` 中，減少對於全域變數的依賴。

`electron\main.ts`

```ts
import path from 'node:path'
import process from 'node:process'
import {
  app,
  BrowserWindow,
  globalShortcut,
  Menu,
  shell,
  Tray,
} from 'electron'
import { version } from '../package.json'

function createTray(
  {
    mainWindow,
  }: {
    mainWindow: BrowserWindow;
  },
) {
  const tray = new Tray(
    path.join(__dirname, '../public/fish.ico'),
  )
  const contextMenu = Menu.buildFromTemplate([
    {
      label: '暫時停用',
      type: 'checkbox',
      click(item) {
        if (item.checked) {
          globalShortcut.unregisterAll()
        }
        else {
          initGlobalShortcut({ mainWindow })
        }
      },
    },
    {
      label: '詳細設定',
      submenu: [
        {
          label: '開啟設定視窗',
        },
      ],
    },
    {
      label: '關於',
      click: () => shell.openExternal('https://codlin.me/column-cod-toys/01-origin.html'),
    },
    { type: 'separator' },
    {
      label: '退出應用程式',
      click: () => app.quit(),
    },
  ])
  tray.setToolTip(`CodToys v${version}`)
  tray.setContextMenu(contextMenu)

  return tray
}

app.whenReady().then(async () => {
  const mainWindow = await createInputWindow()

  initGlobalShortcut({ mainWindow })

  initIpcMain({ configStore })

  const tray = createTray({ mainWindow })

  app.on('window-all-closed', () => { // [!code ++]
    if (process.platform !== 'darwin') { // [!code ++]
      app.quit()// [!code ++]
    }// [!code ++]

    globalShortcut.unregisterAll()// [!code ++]
    tray.destroy()// [!code ++]
  })// [!code ++]
})

app.on('window-all-closed', () => { // [!code --]
  if (process.platform !== 'darwin') { // [!code --]
    app.quit()// [!code --]
  }// [!code --]

  globalShortcut.unregisterAll()// [!code --]
})// [!code --]
```

現在會注意到系統托盤會出現魚的圖示，點擊右鍵會出現更多選單。

![create-tray](/cod-toys/create-tray.png)

### 儲存使用者設定

這裡使用 [electron-store](https://www.npmjs.com/package/electron-store) 來儲存使用者設定。

安裝套件後，第一步先來定義一下使用者設定型別並新增 `ConfigApi`，用於存取使用者設定。
`electron\electron-env.d.ts`

```ts
export interface MainApi {
  // ...
}

export interface UserConfig {
  kaomoji: {
    databaseId: string;
    token: string;
  };
}
export interface ConfigApi {
  get: () => Promise<UserConfig>;
  update: (data: Partial<UserConfig>) => Promise<void>;
  onUpdate: (callback: (config: UserConfig) => void) => void;
}

declare global {
  interface Window {
    main: MainApi;
    config: ConfigApi; // [!code ++]
  }
}

export { }
```

接著在 main process 初始化 store 並註冊 `ipcMain`。

這裡同時重構一下 `ipcMain` 的部分，window 相關控制改為針對發送的 window，不限定只能控制 `mainWindow`。

`electron\main.ts`

```ts{20-30,36-50,72}
import type { UserConfig } from './electron-env'
import {
  app,
  BrowserWindow,
  ipcMain,
  shell,
} from 'electron'
import Store from 'electron-store'

type ConfigStore = Store<{ config: UserConfig }>

function initIpcMain(
  {
    configStore,
  }: {
    configStore: ConfigStore;
  },
) {
  // main
  ipcMain.on('main:updateHeight', (event, height: number) => {
    const window = BrowserWindow.fromWebContents(event.sender)

    window?.setBounds({ height })
  })
  ipcMain.on('main:hideWindow', (event) => {
    const window = BrowserWindow.fromWebContents(event.sender)

    window?.setFocusable(false)
    window?.hide()
  })
  ipcMain.on('main:openExternal', (event, url: string) => {
    shell.openExternal(url)
  })

  // config
  ipcMain.handle('config:get', async () => {
    return configStore.get('config')
  })
  ipcMain.handle('config:update', async (event, config) => {
    const data = configStore.get('config')
    configStore.set('config', {
      ...data,
      ...config,
    })

    // 向所有視窗觸發 config:onUpdate 事件
    BrowserWindow.getAllWindows().forEach((window) => {
      window.webContents.send('config:onUpdate', config)
    })
  })
}

function createConfigStore(): ConfigStore { // [!code ++]
  const config: UserConfig = { // [!code ++]
    kaomoji: { // [!code ++]
      databaseId: '', // [!code ++]
      token: '', // [!code ++]
    }, // [!code ++]
  } // [!code ++]

  return new Store({ // [!code ++]
    name: 'config', // [!code ++]
    defaults: { config }, // [!code ++]
  }) // [!code ++]
} // [!code ++]

app.whenReady().then(async () => {
  const configStore = createConfigStore()

  // ...

  initIpcMain({ configStore })

  // ...
})
```

接著在 preload 實作 API。

`electron\preload.ts`

```ts
// ...

contextBridge.exposeInMainWorld('config', {
  get() {
    return ipcRenderer.invoke('config:get')
  },
  update(data: Partial<UserConfig>) {
    return ipcRenderer.invoke('config:update', data)
  },
  onUpdate(callback: (config: UserConfig) => void) {
    ipcRenderer.on('config:onUpdate', (event, config) => {
      callback(config)
    })
  },
})
```

現在我們可以儲存設定檔了，還需要一個頁面輸入資料才行。

### 開啟設定頁面

預計使用 Vue Router，由於 Electron 本身沒有 Web Server，所以沒辦法直接使用 History 模式，這裡我們將 router 改為 Hash 模式解決。

`src\main.ts`

```ts
import { createRouter, createWebHashHistory } from 'vue-router/auto'

// ...

const router = createRouter({
  history: createWebHashHistory(import.meta.env.BASE_URL),
  routes,
})

// ...
```

接著新增設定頁面吧。

`src\pages\kaomoji-config\index.vue`

```vue
<template>
  <q-form
    class="relative flex-col gap-6 p-6"
    @submit="handleSubmit"
  >
    <q-input
      v-model="form.databaseId"
      outlined
      label="databaseId"
    />

    <q-input
      v-model="form.token"
      outlined
      label="token"
    />

    <q-btn
      label="儲存"
      type="submit"
      unelevated
      color="primary"
    />

    <q-inner-loading :showing="isLoading" />
  </q-form>
</template>

<script setup lang="ts">
import type { UserConfig } from '../../../electron/electron-env'
import { useAsyncState } from '@vueuse/core'
import { useQuasar } from 'quasar'
import { clone } from 'remeda'
import { ref } from 'vue'
import { useConfigApi } from '../../composables/use-config-api'

const configApi = useConfigApi()
const $q = useQuasar()

document.title = '顏文字設定'

const form = ref<UserConfig['kaomoji']>({
  databaseId: '',
  token: '',
})

const {
  isLoading,
} = useAsyncState(
  () => configApi.get(),
  undefined,
  {
    onSuccess(data) {
      if (data) {
        form.value = data.kaomoji
      }
    },
  },
)

function handleSubmit() {
  // clone 處理，避免 Error: An object could not be cloned
  configApi.update(clone({
    kaomoji: form.value,
  })).then(() => {
    $q.notify({
      type: 'positive',
      message: '儲存成功',
    })
  }).catch(() => {
    $q.notify({
      type: 'negative',
      message: '儲存失敗',
    })
  })
}
</script>
```

現在讓我們透過 Tray 的選單開啟此設定頁面吧。

建立 `createConfigWindow` 用於開啟指定頁面並將目標 route path 加在 # 後面即可。

```ts
// ...

async function createConfigWindow(route: keyof RouteNamedMap) {
  const newWindow = new BrowserWindow({
    backgroundColor: '#fff',
    webPreferences: {
      preload: path.join(__dirname, './preload.js'),
    },
  })
  // 隱藏預設系統選單
  newWindow.setMenu(null)

  if (process.env.VITE_DEV_SERVER_URL) {
    await newWindow.loadURL(
      `${process.env.VITE_DEV_SERVER_URL}#${route}`,
    )
    // newWindow.webContents.openDevTools()
  }
  else {
    // loadFile 可以指定 hash
    await newWindow.loadFile('dist/index.html', {
      hash: route,
    })
  }

  return newWindow
}

// ...

function createTray(
  {
    mainWindow,
  }: {
    mainWindow: BrowserWindow;
  },
) {
  // ...
  const contextMenu = Menu.buildFromTemplate([
    {
      label: '暫時停用',
      // ...
    },
    {
      label: '詳細設定',
      submenu: [
        {
          label: '開啟設定視窗',
          click: () => createConfigWindow('/kaomoji-config/'), // [!code ++]
        },
      ],
    },
    // ...
  ])
  // ...
}

// ...
```

:::tip
`RouteNamedMap` 是 `unplugin-vue-router` 自動產生的型別，用於定義所有頁面路由與參數。
:::

現在讓我們從 Tray 開啟設定頁面看看吧！(/≧▽≦)/

![kaomoji-config](/cod-toys/kaomoji-config.png)

...可以看到畫面相當簡潔有力，有機會再來慢慢美化吧。<span class="text-nowrap">( •̀ ω •́ )✧</span>

### 連接 Notion Database

現在讓我們透過 Notion API 來連接指定的 Database 吧！

首先需要先建立 Integrations，前往[設定頁面](https://www.notion.so/profile/integrations)並依照步驟建立。

1. 點擊畫面中的「+ New integration」
1. Associated workspace 選擇要使用的 Workspace
1. Type 選擇 Internal
1. 按下 Save

這樣就建立完成了！接著我們需要取得並調整一下 Token 設定。

在 Integrations 頁面中，點擊剛剛建立的 Integration，會進到設定頁面，讓我們限縮以下此 Token 權限，保持最小權限原則。

基本上就是只有 Read 權限，如下圖。

![notion-token-capabilities](/cod-toys/notion-token-capabilities.png)

複製 Internal Integration Secret 中的 token，並貼到設定頁面中。

接著來建立 Database。

1. 將原本預設的 Name 欄位改名為 value，內容為顏文字
1. 新增一個名為 tags 的多選欄位，用來提供篩選資料
1. 將 database 使用 open as page 開啟
1. 點擊最右上角的三個點，將 Connections 設定為剛剛建立的 Integration

完成後結果會如下圖。

![notion-connections](/cod-toys/notion-connections.png)

最後此 Database 的 URL 會是 `https://www.notion.so/{workspace}/{databaseId}`，將此 URL 中的 databaseId 複製下來，貼到設定頁面中後按下儲存即可。

![save-kaomoji-config](/cod-toys/save-kaomoji-config.png)

### 取得 Notion Database 資料

現在設定資料有了，讓我們串接 Notion API 吧。

安裝 `@notionhq/client` 套件來存取 Notion API 並加入取得資料邏輯。

`src\domains\feature-card-kaomoji\index.vue`

```vue
<template>
  <template v-if="visible">
    <feature-option
      v-if="!isFeature"
      class="p-4"
      icon="emoticon"
      text="輸入 @ 搜尋顏文字"
      :action="() => setText('@')"
    />

    <template v-else>
      <feature-option
        v-for="item, i in list"
        :key="i"
        class="w-full px-4 py-2"
        :action="() => copy(item.value)"
      >
        <div class="flex-1">
          {{ item.value }}
        </div>

        <div class="flex">
          <q-chip
            v-for="tag in item.tags"
            :key="tag"
            :label="tag"
          />
        </div>
      </feature-option>
    </template>
  </template>
</template>

<script setup lang="ts">
import type { UserConfig } from '../../../electron/electron-env'
import { Client } from '@notionhq/client'
import { useAsyncState } from '@vueuse/core'
import dayjs from 'dayjs'
import { get } from 'lodash-es'
import { pipe, reduce, take } from 'remeda'
import { computed, ref, shallowRef, triggerRef } from 'vue'
import FeatureOption from '../../components/feature-option.vue'
import { useConfigApi } from '../../composables/use-config-api'
import { useFeatureStore } from '../../stores/feature.store'

const configApi = useConfigApi()
const featureStore = useFeatureStore()

// ...

const {
  state: config,
  execute: refreshConfig,
} = useAsyncState(
  () => configApi.get(),
  undefined,
  { immediate: false },
)

let notionClient: Client | undefined
function initNotionClient(config: UserConfig) {
  notionClient = new Client({
    auth: config.kaomoji.token,
  })
}

const updatedAt = shallowRef(dayjs())
const notionData = shallowRef<any[]>([])
const startCursor = ref('')
const {
  isLoading: isDataLoading,
  execute: getData,
} = useAsyncState(
  async () => {
    const databaseId = config.value?.kaomoji.databaseId
    if (!databaseId) {
      throw new Error('尚未設定 databaseId')
    }

    return notionClient?.databases.query({
      database_id: databaseId,
      start_cursor: startCursor.value ? startCursor.value : undefined,
    })
  },
  undefined,
  {
    immediate: false,
    onSuccess(result) {
      notionData.value.push(...(result?.results ?? []))

      if (result?.has_more && result.next_cursor) {
        startCursor.value = result.next_cursor
        getData()
        return
      }

      triggerRef(notionData)
      updatedAt.value = dayjs()
    },
  },
)

function refreshData() {
  startCursor.value = ''
  notionData.value = []
  getData()
}

interface ListItem {
  value: string;
  tags: string[];
}
const list = computed(() => pipe(
  notionData.value,
  reduce((acc: ListItem[], result) => {
    acc.push({
      // @notionhq/client 的型別與實際資料有點出入，自行從回應判斷
      value: get(result, 'properties.value.title[0].plain_text', '') as string,
      tags: pipe(
        get(result, 'properties.tags.multi_select', []) as { name: string }[],
        (value) => {
          if (!value) {
            return []
          }

          return value.map((item) => item.name)
        },
      ),
    })

    return acc
  }, []),
  // 先顯示 5 個看看
  take(5),
))

configApi.onUpdate(async (config) => {
  init(config)
})

async function init(config?: UserConfig) {
  const _config = config ?? await refreshConfig()
  if (!_config) {
    return
  }

  initNotionClient(_config)
  refreshData()
}
init()
</script>
```

![get-kaomoji-database-data](/cod-toys/get-kaomoji-database-data.png)

資料進來了！( ´ ▽ ` )ﾉ

接著新增更新用的按鈕，讓使用者可以手動更新資料。

`src\domains\feature-card-kaomoji\index.vue`

```vue
<template>
  <template v-if="visible">
    <feature-option
      v-if="!isFeature"
      ...
    />

    <template v-else>
      <feature-option
        v-for="item, i in paginationList"
        :key="i"
        class="w-full px-4 py-2"
        :action="() => copy(item.value)"
      >
        <div class="flex-1">
          {{ item.value }}
        </div>

        <div class="flex">
          <q-chip
            v-for="tag in item.tags"
            :key="tag"
            :label="tag"
          />
        </div>
      </feature-option>

      <feature-option
        class="relative w-full bg-primary/10 p-4"
        :action="() => refreshData()"
      >
        <div class="w-full flex items-center justify-around">
          <span class="flex-1">
            更新資料
          </span>
          <span class="flex-1 text-right text-xs text-gray-500">
            共 {{ list.length }} 筆，最後更新於 {{ updatedAt.format('YYYY/MM/DD HH:mm:ss') }}
          </span>
        </div>

        <q-inner-loading :showing="isDataLoading" />
      </feature-option>
    </template>
  </template>
</template>
```

![refresh-kaomoji-database-data](/cod-toys/refresh-kaomoji-database-data.gif)

最後讓我們實現分頁功能吧！

## 總結 🐟

以上程式碼可以[在此取得](https://github.com/Codfisher/side-project-cod-toys/tree/feat/kaomoji-database)
